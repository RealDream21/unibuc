---------------CERERI---------------
--12
--1. Afisati numele institutiilor de invatamant a persoanelor din familia care a avut cel mai scump contract de vanzare,
--precum si luna in care au inceput studiul
--elemente folosite: bloc de cerere cu with, functie pe data calendaristica, decode + nvl
WITH max_vanzare AS(  --bloc cerere cu with
    SELECT max(suma)
    FROM contract_cumparare)
SELECT f.nume_familie,  l.prenume,  DECODE(nvl(i.id_forma,0),0,'Nu a terminat o forma de invatamant',i.nume) AS "Nume institutie de Invatamant", to_char(c.an_invatamant, 'Month') luna_incepere --folosire functie pe data calendaristica + NVL si DECODE
FROM familie f JOIN locuitor l ON f.id_familie = l.id_familie FULL OUTER JOIN ciclu_invatamant c ON c.id_locuitor = l.id_locuitor
    FULL OUTER JOIN institutie_invatamant i ON i.id_forma = c.id_forma
WHERE f.id_familie = (SELECT id_familie
                    FROM contract_cumparare
                    WHERE suma = (SELECT * FROM max_vanzare));

--2. Gasiti casa la care locuieste familia care a facut cei mai multi bani din vanzari de pe o strada care are 
--prima litera din numele acestei familii drept nume
--with + functie group + filtru la group by + subcerere nesincronizata cu cel putin 3 tabele  + subcerere nesincronizata in from
--+ functie pe sir de caractere
WITH max_vanzare_familie AS( --clausa with
    SELECT max(sum(suma)) --functie grup
    FROM contract_cumparare cc JOIN familie f ON cc.id_familie = f.id_familie --group by 
    GROUP BY cc.id_familie, f.nume_familie
    HAVING lower(f.nume_familie) = 'tupeiescu') --filtru la group by
SELECT f.id_familie, s.nume_strada, fc.numar, f.nume_familie
FROM familie f JOIN (SELECT id_familie FROM contract_cumparare GROUP BY id_familie HAVING sum(suma) = (SELECT * FROM max_vanzare_familie)) aux on aux.id_familie = f.id_familie --subcerere in FROM
    JOIN familie_casa fc ON fc.id_familie = f.id_familie JOIN strada s ON s.id_strada = fc.id_strada
WHERE fc.data_mutare = (SELECT max(data_mutare) --functie grup + subcerere nesincronizata cu cel putin 3 tabele
                        FROM familie_casa fc2 JOIN strada s ON fc2.id_strada = s.id_strada
                        WHERE fc2.id_familie = f.id_familie
                        AND s.id_strada 
                        IN (SELECT ss.id_strada FROM strada ss WHERE SUBSTR(lower(ss.nume_strada),1, 1) = SUBSTR(lower(f.nume_familie),1, 1)));

--3. Afisati numele(avand toate literele mari), prenumele(eliminand eventualele spatii), numarul de persoane din familie
--si un mesaj in functie de sumele contractelor de vanzare
-- pentru contractele trecut de anul 2000 si pentru familiile care au prefixul pop
--subcerere necorelata in clauza from + functie pe data calendaristica + grupare de date + functie pe siruri de caractere
-- + case 
WITH vanzari_familie_2000 AS(
    SELECT fam.nume_familie nume_familie, contr.suma suma, nr_loc_fam.nr_membrii
    FROM (SELECT * FROM familie WHERE trim(lower(nume_familie)) like ('pop%')) fam JOIN --2 functii pe siruri de caractere + subcereri nesincronizate in from
    (SELECT * FROM contract_cumparare WHERE to_char(data_cumparare, 'YYYY') >= 2000) contr --functie pe data calendaristica
    ON fam.id_familie = contr.id_familie
    LEFT OUTER JOIN(SELECT id_familie, count(*) nr_membrii FROM locuitor GROUP BY id_familie) nr_loc_fam -- grupare de date
    ON nr_loc_fam.id_familie = fam.id_familie
    )
SELECT trim(nume_familie), suma, DECODE(nvl(nr_membrii,0),0,'Nu au fost gasiti membrii', nr_membrii), --functie pe sir de caractere + NVL si DECODE
CASE 
    WHEN suma < 3000 THEN 'Suma mica'
    WHEN (suma >= 3000 AND suma <= 10000) THEN 'Suma medie'
    WHEN suma > 10000 AND suma < 30000 THEN 'Suma mare'  ---Utilizare CASE
    WHEN suma >= 30000 THEN 'Suma foarte mare'
    ELSE 'Alta suma'
END AS "Tip suma"
FROM vanzari_familie_2000;

--4.  Afisati cate evenimente culturale au avut loc in anul 2022 
--sunt luate in considerare doar cele care au capacitatea > minimul capacitatii din randul tuturor evenimentelor conduse de firma cu id 5
--functie pe data calendaristica + functie group + grupari de date cu subcereri nesincronizate cu 3 tabele + filtrare la nivel de grupuri
WITH an_eveniment AS(
        SELECT to_char(data_eveniment, 'YYYY') data_ev,  id_eveniment id_ev --functie pe data calendaristica
        FROM primarie_eveniment
        )
SELECT sum(aux.nr) "Totalul evenimentelor"
FROM (SELECT count(nume_eveniment) nr FROM an_eveniment ae JOIN (SELECT * FROM eveniment_cultural) ec ON ae.id_ev = ec.id_eveniment 
        GROUP BY data_ev, ec.nume_eveniment, ec.capacitate HAVING (data_ev) = '2022' --grupari de date, subcereri nesincronizate cu 3 tabele
        AND ec.capacitate > (SELECT MIN(capacitate) FROM eveniment_cultural GROUP BY id_firma HAVING id_firma = 5)) aux; --filtrare la nivel de grupuri + functie grup
        
--5. Afisati numele tuturor evenimentelor, impreuna cu capacitatea si primaria care le a organizat, in ordine descrescatoare
--in functie de capacitate. Se vor afisa si primariile care nu au organizat evenimente 
--ordonare + decode + nvl 
SELECT DECODE(nvl(ec.capacitate, 0), 0, 'Primaria nu a organizat niciun eveniment', ec.nume_eveniment), DECODE(nvl(ec.capacitate, 0), 0, 0, ec.capacitate), p.nume --decode + nvl
FROM eveniment_cultural ec JOIN primarie_eveniment pe ON ec.id_eveniment = pe.id_eveniment RIGHT OUTER JOIN primarie p ON p.id_primarie = pe.id_primarie 
ORDER BY 2 desc; --ordonari

--13.
--1. Cresteti capacitatea tuturor evenimentelor cu id > 3 cu 150 de locuri fata de media tuturor evenimentelorcu id < 3
UPDATE eveniment_cultural
SET capacitate = capacitate + 150
WHERE id_eveniment IN (SELECT id_eveniment FROM eveniment_cultural WHERE id_eveniment > 3);

--2. Cresteti taxa cu 2 procente tuturor contractelor pentru familiile ce au '%escu%' in nume;
UPDATE contract_cumparare
SET taxa = taxa + 2
WHERE id_familie IN (SELECT id_familie FROM familie WHERE lower(nume_familie) LIKE '%escu%');


--3. Stergeti toate contractele cu suma mai mica de 7500
DELETE
FROM contract_cumparare
WHERE (id_primarie, id_cumparator, id_familie) IN (SELECT id_primarie, id_cumparator, id_familie FROM contract_cumparare WHERE suma <= 7500);

--15
--Cerere cu outer join
--afisati istoricul tuturor caselor la care au stat familii, inclusiv cele la care nu au stat nimeni, precum si primariile acestora,
--iar daca nu au primarie afisati 'In constructie'. De asemenea, afisati institutiile de invatamant prin care au locuitorii
--daca nu au trecut afisati 'Nu are studii la acest nivel'
SELECT UNIQUE DECODE(nvl(id_forma, 0), 0, 'Nu are studi la acest nivel', id_forma) id_studii, 
        fc.id_familie familie, c.id_strada strada, c.numar numar, DECODE(nvl(p.id_primarie, 0), 0, 'In constructie', p.nume) primarie
FROM CICLU_INVATAMANT ci RIGHT OUTER JOIN LOCUITOR l ON ci.id_locuitor = id_familie
        JOIN FAMILIE_CASA fc ON l.id_familie = fc.id_familie
        RIGHT OUTER JOIN CASA c ON (fc.id_strada = c.id_strada AND fc.numar = c.numar)
        LEFT OUTER JOIN PRIMARIE p ON c.id_strada = p.id_strada;

--Cerere cu division
--Afisati primariile care au organizat toate tipurile de evenimente
SELECT p.nume
FROM (SELECT DISTINCT id_eveniment, id_primarie FROM PRIMARIE_EVENIMENT) pe JOIN PRIMARIE p ON pe.id_primarie = p.id_primarie
GROUP BY pe.id_primarie, p.nume
HAVING COUNT(pe.id_eveniment) = (SELECT COUNT(*) FROM EVENIMENt_CULTURAL);

--Cerere cu analiza top-n
--afisati numele familiilor cu primele 5 cele mai scumpe contracte, precum si primaria de care apartin
WITH sume_sortate AS(
    SELECT * FROM contract_cumparare
    ORDER BY SUMA desc)
SELECT f.nume_familie, p.nume, suma
FROM sume_sortate ss JOIN familie f on ss.id_familie = f.id_familie JOIN primarie p on f.id_primarie = p.id_primarie
WHERE ROWNUM <= 5;


--16
--Cererea optimizata este:
--Derivata de la cererea 4 complexa
WITH an_eveniment AS(
        SELECT to_char(data_eveniment, 'YYYY') data_ev,  id_eveniment id_ev --functie pe data calendaristica
        FROM primarie_eveniment
        WHERE to_char(data_eveniment, 'YYYY') = '2022'
        )
SELECT sum(aux.nr) "Totalul evenimentelor"
FROM (SELECT count(nume_eveniment) nr FROM an_eveniment ae JOIN eveniment_cultural ec ON ae.id_ev = ec.id_eveniment 
        GROUP BY data_ev, ec.nume_eveniment, ec.capacitate --grupari de date, subcereri nesincronizate cu 3 tabele
        HAVING ec.capacitate > (SELECT MIN(capacitate) FROM eveniment_cultural GROUP BY id_firma HAVING id_firma = 5)) aux; 


--17
BCNF:
Incalcarea formei normale BCNF se produce atunci când dintr-un atribut non-cheie se poate deduce un atribut cheie. Un exemplu din diagramă ce contravine
acestei convenții ar putea fi, de exemplu, ca în tabela FAMILIE, id-ul familiei să depindă de nume_familie. Pentru a rezolva această problema am putea
creea un nou tabel in care numele de familie este cheie primara, iar din el s-ar deduce id_familie.

FN4:

Forma normală 4 reprezinta aparitia unor perechi de cheie-atribut duplicate. De exemplu, acest lucru s-ar intampla in diagrama proiectată daca, am avea
in tabela PRIMARIE atributul facilitati (Ex: (31, 'Primaria X', 3, 'Cladire iluminata'), (31, 'Primaria X', 3, 'Spatiu verde')). Pentru a rezolva aceasta problema
cel mai bine este sa creem un tabel nou, intitluat, de exemplu, Primarie_facilitati in care sa notam pentru fiecare primarie facilitatile(Ex: (31, 'Cladire Iluminata'), (31, 'Spatiu verde'))

FN5:

Forma normala 5 spune că daca un tabel, in urma descompunerii in alte tabele mai mici isi pierde din informatii, atunci acesta nu ar trebui descompus.
Un exemplu de astfel de tabel este CONTRACT_CUMAPARARE. Daca acesta ar fi descompus in alte doua tabele de exemplu PRIMARIE_CUMPARATOR si CUMPARATOR_FAMILIE s-ar pierde informatia de primaria
care a asistat la cumparator in tranzactia cu familia.


